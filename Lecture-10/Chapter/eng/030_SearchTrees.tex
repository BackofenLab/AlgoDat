\section{Binary Search Trees}

\begin{frame}{Binary Search Trees}{Introduction}
  \textbf{Runtime of a search tree:}
  \begin{itemize}
  \item<3-> {\color{Mittel-Blau}\texttt{next}} and {\color{Mittel-Blau}\texttt{previous}} in $O(1)$
    \begin{itemize}
    \item<4-> pointers corresponding to linked list
    \end{itemize}
  \item<5-> {\color{Mittel-Blau}\texttt{insert}} and {\color{Mittel-Blau}\texttt{remove}} in $O(log~n)$
    \begin{itemize}
    \item<6-> We will see why
    \end{itemize}
  \item<7-> {\color{Mittel-Blau}\texttt{lookup}} in $O(log~n)$
    \begin{itemize}
    \item<8-> The structure helps searching efficiently
    \end{itemize}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Introduction}
  \textbf{Idea:}
  \begin{itemize}
    \item<2->
      We define a total order for the search tree
    \item<3->
      All nodes of the left subtree have {\color{Mittel-Blau}smaller keys}
      than the current node
    \item<4->
      All nodes of the right subtree have {\color{Mittel-Blau}bigger keys}
      than the current node
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Introduction}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Example1.tikz}
    \caption{A binary search tree}
    \label{fig:binary_search_trees:binary_tree_example1}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Introduction}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Example2.tikz}
    \caption{Another binary search tree}
    \label{fig:binary_search_trees:binary_tree_example2}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Introduction}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Example3.tikz}
    \caption{\textbf{Not} a binary search tree}
    \label{fig:binary_search_trees:binary_tree_example3}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation}
  \textbf{Implementation:}
  \begin{itemize}
    \item<2->
      For the heap we had all elements stored in an array
    \item<2->
      Here we link all nodes through pointer / references, like linked lists
    \item<3->
      Each node has a pointer / reference to its children
      (\texttt{\color{Mittel-Blau}leftChild} /
      \texttt{\color{Mittel-Blau}rightChild})
    \item<4->
      \texttt{\color{Mittel-Blau}Null} for missing children
  \end{itemize}
  \onslide<5->
  \vspace{-1.0em}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Impl1.tikz}
    \label{fig:binary_search_trees:binary_tree_impl1}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation}
  \textbf{Implementation:}
  \begin{itemize}
    \item<2->
      We create a sorted doubly linked list of all elements
    \item<3->
      This enables an efficient implementation of
      (\texttt{\color{Mittel-Blau}next} /
      \texttt{\color{Mittel-Blau}previous})
  \end{itemize}
  \onslide<4->
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Impl2.tikz}
    \caption{Binary search tree with links}
    \label{fig:binary_search_trees:binary_tree_impl2}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Lookup}
  \textbf{Lookup:}
  \begin{itemize}
    \item<2->
      Definition:\\
      \enquote{
        Search the element with the given key.
        If no element is found return the element with the next (bigger) key.
      }
    \item<3->
      We search from the root downwards:
      \begin{itemize}
        \item<4->
          Compare the searched key with the key of the node
        \item<5->
          Go to the left / right until the child is
          \texttt{\color{Mittel-Blau}None} or the key is found
        \item<6->
          If the key is not found return the next bigger one
      \end{itemize}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Lookup}
  \textbf{For each node applies the total order:}\\
  \onslide<2->
  \hspace{1.5em}keys of left subtree
  < \texttt{\color{Mittel-Blau}node.key} < keys of right
  subtree
  \onslide<3->
  \begin{columns}
    \begin{column}{0.77\linewidth}
      \begin{figure}
        \begin{adjustbox}{width=\linewidth}
          \input{Images/BinarySearchTree/BinarySearchTree_Impl1.tikz}
        \end{adjustbox}
        \caption{Binary search tree with total order
          \enquote{\color{Mittel-Blau}<}}
        \label{fig:binary_search_trees:binary_tree_lookup}
      \end{figure}
    \end{column}
    \begin{column}{0.23\linewidth}
      \textbf{Examples:}
      %\begin{itemize}[{\color{black!50!white}\footnotesize$\blacksquare$}]
      \begin{itemize}
        \item<4->
          \texttt{\color{red}lookup(14)}
        \item<5->
          \texttt{\color{Mittel-Gruen!50!blue}lookup(6)}
        \item<6->
          \texttt{\color{yellow!50!orange}lookup(19)}
      \end{itemize}
  \end{column}
\end{columns}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Insert}
  \textbf{Insert:}
  \begin{itemize}
    \item<2->
      We search for the key in our search tree
    \item<3->
      If a node is found we replace the value with the new one
    \item<4->
      Else we insert a new node
    \item<5->If the key was not present we get a \texttt{\color{Mittel-Blau}None} entry
    \item<6->We insert the node there
  \end{itemize}
  \onslide<7->
  \vspace{-1em}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Impl1.tikz}
    \caption{Binary search tree with total order
      \enquote{\color{Mittel-Blau}<}}
    \label{fig:binary_search_trees:binary_tree_insert}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Remove}
  \textbf{Remove:} Case 1: The node \enquote{5} has no children\\
  \begin{itemize}
    \item<2->
      Find {\color{Mittel-Blau}parent} of node \enquote{5} (\enquote{6})
    \item<3->
      Set left / right child of node \enquote{6} to
      \texttt{\color{Mittel-Blau}None} depending on position of node \enquote{5}
  \end{itemize}
  \onslide<4->
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Remove.tikz}
    \caption{Binary search tree with total order
      \enquote{\color{Mittel-Blau}<}}
    \label{fig:binary_search_trees:binary_tree_remove_no_child}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Remove}
  \textbf{Remove:} Case 1: The node \enquote{5} has no children\\
  \begin{itemize}
    \item
      Find {\color{Mittel-Blau}parent} of node \enquote{5} (\enquote{6})
    \item
      Set left / right child of node \enquote{6} to
      \texttt{\color{Mittel-Blau}None} depending on position of node \enquote{5}
  \end{itemize}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_RemoveNoChild.tikz}
    \caption{Binary search tree after deleting node \enquote{5}}
    \label{fig:binary_search_trees:binary_tree_remove_no_child_result}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Remove}
  \textbf{Remove:} Case 2: The node \enquote{12} has one child\\
  \begin{itemize}
    \item<2->
      Find the {\color{Mittel-Blau}child} of node \enquote{12} (\enquote{14})
    \item<3->
      Find the {\color{Mittel-Blau}parent} of node \enquote{12} (\enquote{8})
    \item<4->
      Set left / right {\color{Mittel-Blau}child} of node \enquote{8} to
      \enquote{14} depending on position of node \enquote{12}
      (skip node \enquote{14})
  \end{itemize}
  \onslide<5->
  \vspace{-0.5em}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Remove.tikz}
    \vspace{-0.75em}
    \caption{Binary search tree with total order
      \enquote{\color{Mittel-Blau}<}}
    \label{fig:binary_search_trees:binary_tree_remove_one_child}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Remove}
  \textbf{Remove:} Case 2: The node \enquote{12} has one child\\
  \begin{itemize}
    \item
      Find the {\color{Mittel-Blau}child} of node \enquote{12} (\enquote{14})
    \item
      Find the {\color{Mittel-Blau}parent} of node \enquote{12} (\enquote{8})
    \item
      Set left / right {\color{Mittel-Blau}child} of node \enquote{8} to
      \enquote{14} depending on position of node \enquote{12}
      (skip node \enquote{14})
  \end{itemize}
  \vspace{-0.5em}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_RemoveOneChild.tikz}
    \vspace{-0.75em}
    \caption{Binary search tree after delting node \enquote{12}}
    \label{fig:binary_search_trees:binary_tree_remove_one_child_result}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Remove}
  \textbf{Remove:} Case 3: The node \enquote{4} has two children\\
  \begin{itemize}
    \item<2->
      Find the {\color{Mittel-Blau}successor} of node \enquote{4} (\enquote{5})
    \item<3->
      Replace the value of node \enquote{4} with the value of node \enquote{5}
    \item<4->
      Delete node \enquote{5} (the {\color{Mittel-Blau}successor} of node
      \enquote{4}) with remove-case 1 or 2
    \item<5->
      There is no left node because we are deleting the
      {\color{Mittel-Blau}predecessor}
  \end{itemize}
  \onslide<6->
  \vspace{-1.5em}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_Remove.tikz}
    \label{fig:binary_search_trees:binary_tree_remove_two_children}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Implementation - Remove}
  \textbf{Remove:} Case 3: The node \enquote{4} has two children\\
  \begin{itemize}
    \item
      Find the {\color{Mittel-Blau}successor} of node \enquote{4} (\enquote{5})
    \item
      Replace the value of node \enquote{4} with the value of node \enquote{5}
    \item
      Delete node \enquote{5} (the {\color{Mittel-Blau}successor} of node
      \enquote{4}) with remove-case 1 or 2
    \item
      There is no left node because we are deleting the
      {\color{Mittel-Blau}predecessor}
  \end{itemize}
  \onslide
  \vspace{-1.5em}
  \begin{figure}
    \input{Images/BinarySearchTree/BinarySearchTree_RemoveTwoChildren.tikz}
    \label{fig:binary_search_trees:binary_tree_remove_two_children_result}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Binary Search Trees}{Runtime Complexity}
  \textbf{How long takes \texttt{\color{Mittel-Blau}insert} and
    \texttt{\color{Mittel-Blau}lookup}?}
  \begin{itemize}
    \item<2->
      Up to $\Theta(d)$, with $d$ being the
      {\color{Mittel-Blau}depth of the tree}\\
      (The longest path from the root to a leaf)
    \item<3->
      {\color{Mittel-Blau}Best case} with ${\color{Mittel-Blau}d = \log n}$
      the runtime is ${\color{Mittel-Blau}\Theta(\log n)}$
    \item<4->
      {\color{Mittel-Blau}Worst case} with ${\color{Mittel-Blau}d = n}$
      the runtime is ${\color{Mittel-Blau}\Theta(n)}$
    \item<5->
      If we \textbf{always} want to have a runtime of $\Theta(\log n)$ then
      we have to {\color{Mittel-Blau}rebalance} the tree
  \end{itemize}
  \onslide<6->
  \vspace{-2.0em}
  \begin{columns}%
    \begin{column}[b]{0.4\textwidth}%
      \begin{figure}%
        \input{Images/BinarySearchTree/BinaryTreeWorst.tikz}%
        \caption{Degenerated binary tree ${\color{Mittel-Blau}d = n}$}%
      \end{figure}%
    \end{column}%
    \begin{column}[b]{0.6\textwidth}%
      \onslide<7->
      \begin{figure}%
        \input{Images/BinarySearchTree/BinaryTreeBest.tikz}%
        \caption{Complete binary tree ${\color{Mittel-Blau}d = \log n}$}%
        \vspace{0.85em}%
      \end{figure}%
    \end{column}%
  \end{columns}%
\end{frame}
