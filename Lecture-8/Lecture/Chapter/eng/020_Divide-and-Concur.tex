\section{Divide and Concur}



\begin{frame}{Divide and Concur}{Table of content}
	\begin{itemize}
		\item
			Concept
		\item
			Maximum subtotal
		\begin{itemize}
			\item
				Approach to a problem
			\item
				Divide and concur approach
			\item
				Runtime
		\end{itemize}
		\item
			Recursion equation
		\begin{itemize}
			\item
				Substitution method
			\item
				Recursion tree method
			\item
				Master theorem
		\end{itemize}
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Concept}
	\begin{itemize}
		\item
			Divide the overall problem into smaller subproblems.
		\item
			Concur over the subproblems through solving recursively. If subproblems 
			are small, solve directly.
		\item
			Connect the solutions of the subproblems to the solutions of the 
			overall problem.
		\item
			Recursive application of the algorithm for smaller subproblems 
		\item
			Direct solution for a small subproblem
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Concept}
	Method V for solution of the problem P of size n
	
	TODO: Look at slide 26 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Features}
	Can be for conceptual hard problems helpful
	\begin{itemize}
		\item
			The trivial solution has to be known
		\item
			Dividing in subproblems has to be possible
		\item
			A combination of parts of the solution has to be possible 
	\end{itemize}
	Realize efficient solutions
	\begin{itemize}
		\item
			if the trivial solution is in $\mathcal{O}(1)$, separating in subproblems 
			and combinations of the parts of the solution in $\mathcal{O}(n)$ and the 
			number subproblems is limited, is the algorithm in $\mathcal{O}(n \log n)$
	\end{itemize}
	Suitable for parallel processing
	\begin{itemize}
		\item
			The parts of the problem are processed independently
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Implementation}
	Definition of the trivial solution
	\begin{itemize}
		\item
			Small directly solvable subproblems are smart and easy
		\item
			Otherwise the efficiency will be improved, if relative big subproblems 
			can be solved
		\item
			Recursion depth should not be to big
	\end{itemize}
	Dividing in subproblems
	\begin{itemize}
		\item
			choosing the number of subproblems and the concrete allocation  can be 
			demanding
	\end{itemize}
	Combinations of parts of the solution
	\begin{itemize}
		\item
			typically conceptional demanding
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Maximum subsum}
	\textbf{Input:}
	\begin{itemize}
		\item
			Progression X of n whole numbers
	\end{itemize}
	\textbf{Output:}
	\begin{itemize}
		\item
			Maximum sum of related subsequence of X and its index boundary
	\end{itemize}
	\textbf{Input:}
	\begin{itemize}
		\item
			TODO: Table -> look at slide 30 \vspace{2em}
	\end{itemize}
	\textbf{Output:}
	\begin{itemize}
		\item
			187, 2, 6
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Application}
	\begin{itemize}
		\item
			Maximum profit while buying and selling stock
	\end{itemize}
	
	TODO: Graphics -> look at slide 31 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Brute Force}
	
	TODO: Code -> look at slide 32 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Python implementation}
	
	TODO: Python Code -> look at slide 33 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Runtime upper bound}
	
	TODO: Code -> look at slide 34 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Runtime lower bound}

TODO: Table -> look at slide 35 \vspace{2em}

	\begin{itemize}
		\item
			There are a minimum of $\dfrac{n}{3}$ values for u, for $\dfrac{n}{3}$ 
			values passed through o, for which again run through $\dfrac{n}{3}$ 
			addition steps in the inner loop
		\item
			We need a minimum of $T(n) = \left(\dfrac{n}{3}\right)^3 \in \Omega 
			(n^3)$ steps
		\item
			$T(n) \in \mathcal{O}(n^3)$ and $T(n) \in \Omega(n^3)$ follows $T(n) \in 
			\Theta (n^3)$
		\item
			it is hard to solve the problem worse ...
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{More efficient alternative}
	... but its easier to solve it better
	\begin{itemize}
		\item
			Until now:\\
			For every u and for every o we calculate $S_{u,o} = X(u) + X(u+1) + \dots 
			+ X(o)$
		\item
			More efficient:\\
			incremental actualization instead of pass through loops\\
			from $S_{u,o+1} = X(u) + X(u+1) + \dots + X(o) + X(o+1)$\\
			and $S_{u,o} = X(u) + X(u+1) + \dots + X(o)$\\
			follows $S_{u,o+1} = S_{u,o} + X(o+1)$ $\rightarrow$ $\mathcal{O}(1)$ 
			instead of $\mathcal{O}(n)$
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Better solution}
	
	TODO: Code -> look at slide 37 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Python Code}
	
	TODO: Python Code -> look at slide 38 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Idea}
	\begin{itemize}
		\item
		Solve the problem for the left and the right half of X
		\item
			Put the parts of the solution together to the overall solution
	\end{itemize}
	
	TODO: Graphics -> look at slide 39 \vspace{2em}
	
	\begin{itemize}
		\item
			The Maximum is either in the left half (A) or in the right half (B)
		\item
			The Maximum can also be on the border of both half's (C) 
		\item
			For C we have to determine rmax and lmax
		\item
			The overall solution is a maximum of A, B, C
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Concept}
	\begin{itemize}
		\item
			Small problems will be solved directly: n=1 $\Rightarrow$ Max = X(0)
		\item
			Big problems will be divided in two subproblems and solved recursively. 
			Parts of the solution A and B will be delivered.
	\end{itemize}
	
	TODO: Graphics -> look at slide 40 \vspace{2em}
	
	\begin{itemize}
		\item
			To determine parts of the solution C, we will determine rmax and lmax for 
			the subproblem.
		\item
			The overall solution results in the maximum of A, B, C
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Implementation}
	
	TODO: Code -> look at slide 42 \vspace{2em}
	
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Divide and Concur}{Python Code}
	
	TODO: Python Code -> look at slide 43 \vspace{2em}
	
\end{frame}