\section{Balanced Trees}

\subsection{Motivation}

\begin{frame}{Balanced Trees}{Motivation}
  \textbf{Binary search tree:}
  \begin{itemize}
  \item<2->
    With \texttt{\color{Mittel-Blau}BinarySearchTree} we could perform an
    \texttt{\color{Mittel-Blau}lookup} or
    \texttt{\color{Mittel-Blau}insert} in $O(d)$, with $d$ being
    the {\color{Mittel-Blau}depth} of the tree
  \item<3->
    {\color{Mittel-Blau}Best case}: $d = O(\log n)$
    \begin{itemize}
    \item<4-> If the keys are inserted randomly
    \end{itemize}   
  \item<5->
    {\color{Mittel-Blau}Worst case}: $d = O(n)$
    \begin{itemize}
    \item<6->if the keys are inserted in ascending / descending
      order $(20, 19, 18, \dotsc)$
    \end{itemize}  
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Balanced Trees}{Motivation}
  \textbf{Gnarley trees:}\hfill
  \qrcode[height=5em]{\GnarleyTreesLink}\\
    \begin{itemize}
    \item http://people.ksp.sk/~kuko/bak
    \end{itemize}  
  \vspace{-1.0em}
  \begin{columns}
    \begin{column}[t]{0.5\linewidth}
      \begin{figure}
        \includegraphics[width=\linewidth]{Images/Motivation/BinarySearchTree_Random.png}
        \caption{Binary search tree with random insert~\cite{gnarley_trees}}
        \label{fig:motivation:binary_search_tree_random}
      \end{figure}
    \end{column}
    \begin{column}[t]{0.5\linewidth}
      \begin{figure}
        \includegraphics[width=\linewidth]{Images/Motivation/BinarySearchTree_Ordered.png}
        \caption{Binary search tree with descending insert~\cite{gnarley_trees}}
        \label{fig:motivation:binary_search_tree_ordered}
      \end{figure}
    \end{column}
  \end{columns}
 
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Balanced Trees}{Motivation}
  \textbf{Balanced trees:}
  \begin{itemize}
    \item<2->
      We do not want to rely on certain properties of our {\color{Mittel-Blau}key set}
    \item<3->
      We explicitly want a depth of ${\color{Mittel-Blau}O(\log n)}$
    \item<4->
      We {\color{Mittel-Blau}rebalance} the tree from time to time
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Balanced Trees}{Motivation}
  \textbf{How do we get a depth of $O(\log n)$?}
  \begin{itemize}
    \item<2->
      \textbf{AVL-Tree:}
      \begin{itemize}
        \item<3->
          Binary tree with 2 children per node
        \item<4->
          Balancing via \enquote{\color{Mittel-Blau}rotation}
      \end{itemize}
    \item<5->
      \textbf{(a,b)-Tree} or \textbf{B-Tree:}
      \begin{itemize}
        \item<6->
          Node have between ${\color{Mittel-Blau}a}$ and
          ${\color{Mittel-Blau}b}$ children
        \item<7->
          Balancing through {\color{Mittel-Blau}splitting} and
          {\color{Mittel-Blau}merging} nodes
        \item<8->
          Used in data bases and file systems
      \end{itemize}
    \item<9->
      \textbf{Red-Black-Tree:}
      \begin{itemize}
        \item<10->
          Binary tree with \enquote{black} and \enquote{red} nodes
        \item<11->
          Balancing through \enquote{\color{Mittel-Blau}rotation} and
          \enquote{\color{Mittel-Blau}recoloring}
        \item<12->
          Can be interpreted as (2, 4)-tree
        \item<13->
          Used in C++ std::map, Java SortedMap
      \end{itemize}
  \end{itemize}
\end{frame}
