\section{Dijkstra Algorithm}

\begin{frame}{Dijkstra Algorithm}{Shortest Path without Computer}
  \begin{itemize}
    \item
      Wanted: Shortest path from M to all other points
    \item
      Place pearls on crossings and clamp strings between them
  \end{itemize}
  \begin{figure}
    \includegraphics[width=0.75\linewidth]{Images/Dijkstra/DijkstraMap}
    \caption{Map $\copyright\,$ Mehlhorn / Sanders}
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Shortest Path without Computer}
  \vspace{-1.5em}
  \begin{columns}
    \begin{column}{0.55\linewidth}
      \begin{figure}[!t]
        \includegraphics[width=0.8\linewidth]
          {Images/Dijkstra/DijkstraMap}
        \caption{Map $\copyright\,$ Mehlhorn / Sanders}
      \end{figure}
      \vspace{-1.5em}
      \begin{itemize}
        \item
          Take the net and pull it slowly upwards until fully lifted
        \item
          Each node (pearl) now has a specific height
        \item
          The distance to M is exactly the {\color{Mittel-Blau}shortest path}
      \end{itemize}
    \end{column}
    \begin{column}{0.45\linewidth}
      \begin{figure}[!t]
        \includegraphics[width=\linewidth]
          {Images/Dijkstra/DijkstraTree_WithOverlay}
        \vspace{-0.5em}
        \caption{Map $\copyright\,$ Mehlhorn / Sanders}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Shortest Path}
  \vspace{-1.5em}
  \begin{figure}
    \begin{adjustbox}{width=0.75\linewidth}
      \input{Images/Dijkstra/ShortestPath.tikz}
    \end{adjustbox}
    \label{fig:dijkstra:shortest_path_introduction}
    \caption{Shortest path from {\color{Mittel-Blau}$s$} to
    {\color{Mittel-Blau}$t$}}
  \end{figure}
  \vspace{-1.5em}
  \begin{itemize}
    \item
      Let {\color{Mittel-Gruen}$r$} be the shortest path from
      {\color{Mittel-Blau}$s$} to {\color{Mittel-Blau}$t$}
    \item
      For each node {\color{Mittel-Blau}$u$} on path {\color{Mittel-Gruen}$r$}
      the path from {\color{Mittel-Blau}$u$} to {\color{Mittel-Blau}$t$} is
      the shortest path
  \end{itemize}
  \textbf{Proof:}
  \begin{itemize}
    \item
      If there was a shorter path from {\color{Mittel-Blau}$s$} to
      {\color{Mittel-Blau}$u$} then we could choose this path to get faster to
      {\color{Mittel-Blau}$t$}
    \item
      Then {\color{Mittel-Gruen}$r$} would not be the shortest path
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Shortest Path}
  \vspace{-1.5em}
  \begin{figure}
    \begin{adjustbox}{width=0.75\linewidth}
      \input{Images/Dijkstra/ShortestPath.tikz}
    \end{adjustbox}
    \label{fig:dijkstra:shortest_path_introduction_re}
    \caption{Shortest path from {\color{Mittel-Blau}$s$} to
      {\color{Mittel-Blau}$t$}}
  \end{figure}
  \vspace{-1.5em}
  \begin{itemize}
    \item
      Let {\color{Mittel-Gruen}$r$} be the shortest path from
      {\color{Mittel-Blau}$s$} to {\color{Mittel-Blau}$t$}
    \item
      For each node {\color{Mittel-Blau}$u$} on path {\color{Mittel-Gruen}$r$}
      the path from {\color{Mittel-Blau}$u$} to {\color{Mittel-Blau}$t$} is
      the shortest path
    \item
      This is also correct for all sub paths on {\color{Mittel-Gruen}$r$}
    \item
      If the shortest path from {\color{Mittel-Blau}$s$} to
      {\color{Mittel-Blau}$t$} passes {\color{Mittel-Blau}$u_1$} and
      {\color{Mittel-Blau}$u_2$} then the sub path
      $({\color{Mittel-Blau}u_1}, {\color{Mittel-Blau}u_2})$
      is the shortest path from {\color{Mittel-Blau}$u_1$} to
      {\color{Mittel-Blau}$u_2$}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Shortest Path}
  \begin{figure}%
    \begin{adjustbox}{width=0.75\linewidth}%
      \input{Images/Dijkstra/ShortestPaths.tikz}%
    \end{adjustbox}%
    \vspace{-1.0em}
    \label{fig:dijkstra:shortest_paths_introduction}%
    \caption{Shortest paths from {\color{Mittel-Blau}$s$} to
      {\color{Mittel-Blau}$t$}}
  \end{figure}
  \vspace{-1.0em}
  \begin{itemize}
    \item
      If we know the shortest path form {\color{Mittel-Blau}$s$}
      to the preceding nodes of {\color{Mittel-Blau}$t$}
      \begin{math}
        (
          {\color{Mittel-Blau}v_1},
          {\color{Mittel-Blau}v_2},
          {\color{Mittel-Blau}v_3}
        )
       \end{math}
       we can determine the shortest path to {\color{Mittel-Blau}$t$}
   \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Shortest Path}
  \textbf{Idea:}
  \begin{itemize}
    \item
      Attach the cost of the shortest path to each node
    \item
      Let the information travel over the edges (message passing)
    \item
      In which order should we process the nodes?
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \begin{columns}
    \begin{column}{0.6\linewidth}
      \textbf{Inventor:}
      \begin{itemize}
        \item
          Edsger Dijkstra (1930 - 2002)
        \item
          Computer scientist from Netherlands
        \item
          Won Turing-Award as one of few Europeans for his studies of 
          structured programming
        \item
          Invented the Dijkstra-Algorithm in 1959
      \end{itemize}
    \end{column}
    \begin{column}{0.4\linewidth}
      \begin{figure}
        \includegraphics[width=0.75\linewidth]
          {Images/Dijkstra/Edsger_Wybe_Dijkstra.jpg}
        \caption{Portrait \copyright\; Hamilton Richards - manuscripts of
          Edsger W. Dijkstra, University Texas at Austin}
        \label{fig:dijkstra:portrait}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \vspace{-1.5em}
  \begin{columns}
    \begin{column}{0.55\linewidth}
      \textbf{Example:}
      \begin{itemize}
        \item
          Lift pearl {\color{Mittel-Blau}$M$} a little bit
        \item
          Connections to pearls {\color{Mittel-Blau}$R$},
          {\color{Mittel-Blau}$L$} and {\color{Mittel-Blau}$G$} are hanging in
          the air
        \item
          Lift further until pearl {\color{Mittel-Blau}$R$} starts to lift at
          $\SI{5}{m}$
        \item
          The shortest path to {\color{Mittel-Blau}$R$} is now known
        \item
          Lift further: The wires from {\color{Mittel-Blau}$R$},
          {\color{Mittel-Blau}$O$} and {\color{Mittel-Blau}$Q$} are now in the
          air
        \item
          One of the pearls {\color{Mittel-Blau}$G$}, {\color{Mittel-Blau}$L$},
          {\color{Mittel-Blau}$Q$} or {\color{Mittel-Blau}$O$} is the next one\\
          {\color{gray}Which one?}
      \end{itemize}
    \end{column}
    \begin{column}{0.45\linewidth}
      \begin{figure}[!t]
        \includegraphics[width=\linewidth]
          {Images/Dijkstra/DijkstraTree_WithOverlay}
        \vspace{-0.5em}
        \caption{Map $\copyright\,$ Mehlhorn / Sanders}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \vspace{-1.5em}
  \begin{columns}
    \begin{column}{0.55\linewidth}
      \textbf{Example:}
      \begin{itemize}
        \item
          At $\SI{11}{m}$ pearl {\color{Mittel-Blau}$L$} gets lifted
        \item
          The wires to {\color{Mittel-Blau}$N$} and {\color{Mittel-Blau}$K$}
          are now in the air
        \item
          One of the pearls {\color{Mittel-Blau}$G$}, {\color{Mittel-Blau}$K$},
          {\color{Mittel-Blau}$N$}, {\color{Mittel-Blau}$Q$} or
          {\color{Mittel-Blau}$O$} is the next one\\
          {\color{gray}Which one?}
        \item
          At $\SI{13}{m}$ pearl {\color{Mittel-Blau}$O$} gets lifted\\
          $\cdots$
        \item
          {\color{gray}How to translate this into an computer algorithm?}
      \end{itemize}
    \end{column}
    \begin{column}{0.45\linewidth}
      \begin{figure}[!t]
        \includegraphics[width=\linewidth]
        {Images/Dijkstra/DijkstraTree_WithOverlay}
        \vspace{-0.5em}
        \caption{Map $\copyright\,$ Mehlhorn / Sanders}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \textbf{High level description:}
  Three types of nodes
  \begin{itemize}
    \item
      {\color{Mittel-Blau}Settled:}
      For node {\color{Mittel-Blau}$u$} we know
      {\color{Mittel-Blau}$\mathrm{dist}(s, u)$}
      \hfill
      \raisebox{-0.5em}{\begin{adjustbox}{height=1.5em}%
        \input{Images/Dijkstra/Vertex/Vertex_Settled.tikz}%
      \end{adjustbox}}\\
      {\color{gray}(Pearl example: This preal is hanging in the air)}
      \vspace{0.5em}
    \item
      {\color{Mittel-Blau}Active:}
      For node {\color{Mittel-Blau}$u$} we know a tentative distance
      {\color{Mittel-Blau}$\mathrm{td}(u) \geq \mathrm{dist}(s, u)$}
      (Can be optimal but doesn't have to)
      \hfill
      \raisebox{-0.5em}{\begin{adjustbox}{height=1.5em}%
        \input{Images/Dijkstra/Vertex/Vertex_Active.tikz}%
      \end{adjustbox}}\\
      {\color{gray}(Pearl example: This pearl is laying on the table but\\
        one connected wire is already in the air)}
        \vspace{0.5em}
    \item
      {\color{Mittel-Blau}Unreached:}
      We have not reached the node yet
      \hfill
      \raisebox{-0.5em}{\begin{adjustbox}{height=1.5em}%
          \input{Images/Dijkstra/Vertex/Vertex_Unreached.tikz}%
        \end{adjustbox}}\\
        {\color{gray}(Pearl example: This preal is hanging in the air)}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \textbf{High level description:}
  \begin{itemize}
    \item
      Each iteration take the {\color{Mittel-Blau}active} node
      {\color{Mittel-Blau}$u$} with the
      {\color{Mittel-Blau}smallest $\mathrm{td}(u)$}\\
      {\color{gray}(The pearl getting lifted next)}
    \item
      We update the state of the node {\color{Mittel-Blau}$u$} to
      {\color{Mittel-Blau}settled}\\
      {\color{gray}(The pearl gets lifted)}
    \item
      We check for each {\color{Mittel-Blau}neighbor $v$} of node
      {\color{Mittel-Blau}$u$} if we can reach {\color{Mittel-Blau}$v$} faster
      than currently possible\\
      {\color{gray}(Check all outgoing wires from this pearl:
        Activate all connected pearls, update
        tentative distance if smaller)}
    \item
      Iterate until no active nodes exist anymore
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \vspace{-1em}
  \begin{figure}[!h]
    \begin{adjustbox}{width=\linewidth}
      \def\DijkstraReverse{0}%
      \input{Images/Dijkstra/Dijkstra_Algorithm.tikz}
    \end{adjustbox}
    \vspace{-2em}
    \caption{%
      \only<1>{Start at {\color{Mittel-Blau}$u_1$}}%
      \only<2>{Iteration 1}%
      \only<3>{Iteration 2}%
      \only<4>{Iteration 3}%
      \only<5>{Iteration 4}%
      \only<6>{Iteration 5}%
      \only<7>{Iteration 6}%
    }
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof}
  \textbf{Proof:}
  \begin{itemize}
    \item
      \textbf{Assumption 1:}
      All edges have a positive length
    \item
      \textbf{Assumption 2:}
      Each node has a unique distance
      {\color{Mittel-Blau}$\mathrm{dist}(s, u)$}\\
      {\color{gray}(This was not the case on the previous slides)}\\[0.5em]
      This results in an easy and intuitive proof.\\
      {\color{gray}
        It is prossible to show this without assumption 2.
        See references if interested}
      \vspace{1.0em}
    \item
      With assumption 2 there exists a sorting {\color{Mittel-Blau}$u_1$},
      {\color{Mittel-Blau}$u_2$}, $\ldots$ with that:
      \begin{displaymath}
        {\color{Mittel-Blau}\mathrm{dist}(s, u_1)} <
        {\color{Mittel-Blau}\mathrm{dist}(s, u_2)} <
        {\color{Mittel-Blau}\mathrm{dist}(s, u_3)} <
        \ldots
      \end{displaymath}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof}
  \textbf{Proof:}
  \begin{itemize}
    \item
      With \textbf{assumption 2} there exists a sorting {\color{Mittel-Blau}$u_1$},
      {\color{Mittel-Blau}$u_2$}, $\ldots$ with that:
      \begin{displaymath}
        {\color{Mittel-Blau}\mathrm{dist}(s, u_1)} <
        {\color{Mittel-Blau}\mathrm{dist}(s, u_2)} <
        {\color{Mittel-Blau}\mathrm{dist}(s, u_3)} <
        \ldots
      \end{displaymath}
    \item
      We want to show that the \textit{Dijkstra} algorithm finds the shortest
      path for each node {\color{Mittel-Blau}$u_i$} so that
      {\color{Mittel-Blau}$\mathrm{td}(u_i) = \mathrm{dist}(s, u_i)$} holds
    \item
      Additionally we show that each node gets solved in order of the distance:
      Node {\color{Mittel-Blau}$u_i$} gets solved in iteration
      {\color{Mittel-Blau}$i$}
      \begin{displaymath}
        {\color{Mittel-Blau}u_1},
        {\color{Mittel-Blau}u_2},
        {\color{Mittel-Blau}u_3},
        \ldots
      \end{displaymath}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof}
  \textbf{To show:} Node {\color{Mittel-Blau}$u_i$} gets solved in round
  {\color{Mittel-Blau}$i$}
  \begin{enumerate}
    \item
      Node {\color{Mittel-Blau}$u_i$} contains the correct distance
      ({\color{Mittel-Blau}$\mathrm{td}(u_i) = \mathrm{dist}(s, u_i)$})
      and is active
    \item
      Node {\color{Mittel-Blau}$u_i$} has the smallest value for
      {\color{Mittel-Blau}$\mathrm{td}(u_i)$} and gets selected by the algorithm
  \end{enumerate}
  \vspace{1.0em}
  \textbf{Induction start:}
  \begin{enumerate}
    \item
      \begin{itemize}
        \item
          Only the start node {\color{Mittel-Blau}$s = u_1$} is active and
          {\color{Mittel-Blau}$\mathrm{td}(s) = 0$}
        \item
          Node {\color{Mittel-Blau}$u_1$} gets solved and
          {\color{Mittel-Blau}$\mathrm{td}(u_1) = \mathrm{dist}(s, u_1) = 0$})
      \end{itemize}
    \item
      Only the start node {\color{Mittel-Blau}$u_1$} is active
  \end{enumerate}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof}
  \textbf{Induction step:} {\color{Mittel-Blau}$i = i+1$}
  \begin{enumerate}
    \item
      \textbf{To show:} Node {\color{Mittel-Blau}$u_i$} contains the correct
      distance ({\color{Mittel-Blau}$\mathrm{td}(u_i) = \mathrm{dist}(s, u_i)$})
      and is active
      \begin{itemize}
        \item
          On the shortest path from {\color{Mittel-Blau}$s$} to
          {\color{Mittel-Blau}$u_{i+1}$} is a preceding node that:
          \begin{displaymath}
            \color{Mittel-Blau}\mathrm{dist}(s, u_{i+1})
            = \mathrm{dist}(s, v) + \mathrm{c}(v, u_{i+1})
          \end{displaymath}
          ({\color{Mittel-Blau}$c$} are the costs of the edge)
          \begin{figure}[!h]
            \begin{adjustbox}{width=0.9\linewidth}
              \def\DijkstraTD{0}%
              \input{Images/Dijkstra/Dijkstra_InductionOrder.tikz}
            \end{adjustbox}
          \end{figure}
        \item
          With that results
          {\color{Mittel-Blau}$\mathrm{dist}(s, v) < \mathrm{dist}(s, u_{i+1})$}
          because {\color{Mittel-Blau}$c > 0$}
        \item
          Because {\color{Mittel-Blau}$u_{i+1}$} is currently solved node
          {\color{Mittel-Blau}$v$} is one of the preceding nodes
          {\color{Mittel-Blau}$u_1, \dots, u_i$}, hence
          {\color{Mittel-Blau}$v = u_j$} with
          {\color{Mittel-Blau}$0 \leq j \leq i$}
      \end{itemize}
  \end{enumerate}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof - Example of Iteration 6}
  \begin{figure}[!h]
    \begin{adjustbox}{width=0.9\linewidth}
      \input{Images/Dijkstra/Dijkstra_Induction.tikz}
    \end{adjustbox}
  \end{figure}
  \begin{itemize}
    \item
      Preceding node of {\color{Mittel-Blau}$u_6$} is
      {\color{Mittel-Blau}$v = u_3$}
    \item
      In round 3
      \begin{math}
        {\color{Mittel-Blau}\mathrm{td}(u_6) = }
        {\color{Hell-Gruen}\;2 + 4\;}
        {\color{Mittel-Blau} = 6}
      \end{math}
      was already solved
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof}
  \begin{figure}[!h]
    \begin{adjustbox}{width=0.9\linewidth}
      \def\DijkstraTD{1}%
      \input{Images/Dijkstra/Dijkstra_InductionOrder.tikz}
    \end{adjustbox}
  \end{figure}
  \begin{enumerate}
    \item
      \textbf{To show:} Node {\color{Mittel-Blau}$u_i$} contains the correct
      distance ({\color{Mittel-Blau}$\mathrm{td}(u_i) = \mathrm{dist}(s, u_i)$})
      and is active
      \begin{itemize}
        \item
          With \textbf{induction assumption}:
          {\color{Mittel-Blau}$v$} already contains the correct distance which
          was evaluated in round {\color{Mittel-Blau}$j$}\\
          (edge from {\color{Mittel-Blau}$v$} to {\color{Mittel-Blau}$u_{i+1}$})
          and is stored in {\color{Mittel-Blau}$\mathrm{td}(u_{i+1})$}
        \item
          {\color{Mittel-Blau}$u_{i+1}$} is active because the preceding node
          was solved
      \end{itemize}
  \end{enumerate}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Proof}
  \begin{figure}[!h]
    \begin{adjustbox}{width=0.9\linewidth}
      \def\DijkstraTD{1}%
      \input{Images/Dijkstra/Dijkstra_InductionOrder.tikz}
    \end{adjustbox}
  \end{figure}
  \begin{enumerate}
    \setcounter{enumi}{1}
    \item
      \textbf{To show:} Node {\color{Mittel-Blau}$u_i$} has the smallest
      value for {\color{Mittel-Blau}$\mathrm{td}(u_i)$} and gets selected by
      the algorithm
      \begin{itemize}
        \item
          All nodes with smaller {\color{Mittel-Blau}$\mathrm{dist}$} are
          already solved
        \item
          All other nodes {\color{Mittel-Blau}$u_k$} with
          {\color{Mittel-Blau}$k > i + 1$} have a greater
          {\color{Mittel-Blau}$\mathrm{dist}(s, u_k)$}
          an with that the  {\color{Mittel-Blau}$\mathrm{td}(u_k)$} is greater
          or equal
        \item[$\Rightarrow$]
          {\color{Mittel-Blau}$u_{i+1}$} is the node with the
          smallest {\color{Mittel-Blau}$\mathrm{td}$} and gets selected by the
          algorithm
      \end{itemize}
  \end{enumerate}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Implementation}
  \textbf{Implementation:}
  \begin{itemize}
    \item
      We have to manage a set of {\color{Mittel-Blau}active nodes}
    \item
      We start with only the {\color{Mittel-Blau}start node} in our set
    \item
      At the start of each iteration we need the node
      {\color{Mittel-Blau}$u$} with the smallest
      {\color{Mittel-Blau}$\mathrm{td}(u)$}\\[0.5em]
      {\color{gray}How to implement this?}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Implementation}
  \textbf{Implementation:}
  \begin{itemize}
    \item
      Using a {\color{Mittel-Blau}priority queue} with
      {\color{Mittel-Blau}$\mathrm{td}(u)$} as keys
    \item
      The following problem occurs:
      \begin{itemize}
        \item
          The {\color{Mittel-Blau}tentative distance} of an active node might
          change multiple times before it is settled
        \item
          We have to change the key in our {\color{Mittel-Blau}priority queue}
          without removing the entry
      \end{itemize}
  \end{itemize}
  \vspace{1em}
  \textbf{Limitations:}
  \begin{itemize}
    \item
    Often only \texttt{insert}, \texttt{getMin} and \texttt{deleteMin}
    are implemented
    \item[$\Rightarrow$]
    We only have access to the first element and not any desired one
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Implementation}
  \textbf{Alternative:}
  \begin{itemize}
    \item
      If a node reoccurs with a smaller {\color{Mittel-Blau}$\mathrm{dist}$}
      we insert the element one more time into the
      {\color{Mittel-Blau}priority queue}\\
      {\color{gray}(We do nothing if the distance is greater or equal)}
    \item
      We do not remove the old entry
    \item
      The node always gets solved with the smallest distance because of the
      priority
    \item
      If a node reoccurs with a higher {\color{Mittel-Blau}$\mathrm{dist}$}
      we remove it and do simply {\color{Mittel-Blau}nothing}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Implementation - Example}
  \begin{columns}[T]
    \begin{column}{0.6\linewidth}
      \begin{center}
        \begin{adjustbox}{width=0.9\linewidth}
          \input{Images/Dijkstra/PriorityQueue.tikz}
        \end{adjustbox}
      \end{center}
    \end{column}
    \begin{column}{0.4\linewidth}
      Priority queue:
    \end{column}
  \end{columns}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Runtime analysis}
  Graph with {\color{Mittel-Blau}$n$} nodes and {\color{Mittel-Blau}$m$}
  edges: ({\color{Mittel-Blau}$m \geq n$})
  \begin{itemize}
    \item
      Each node gets solved exactly {\color{Mittel-Blau}one time}
    \item
      When solving a node it's outgoing edges are taken into account
    \item
      Each edge triggers at maximum one \texttt{insert} operation
    \item
      The number of operations on the {\color{Mittel-Blau}priority queue}
      is at maximum {\color{Mittel-Blau}$O(m)$}
    \item
      This results in a runtime of
      {\color{Mittel-Blau}$O(m \cdot \log m)$}\\
      {\color{gray}($\log m$ because of at max. $m$ elements in the priority
        queue)}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Runtime analysis}
  Runtime of {\color{Mittel-Blau}$O(m \cdot \log m)$}:
  \begin{itemize}
    \item
      Because of {\color{Mittel-Blau}$m \leq n^2$} we have a maximum runtime of
      {\color{Mittel-Blau}$O(m \cdot \log n)$}, because
      {\color{Mittel-Blau}$\log n^2 = 2 \, \log n$}
    \item
      With a complex {\color{Mittel-Blau}priotity queue} the runtime can be
      reduced to {\color{Mittel-Blau}$O(m + n \, \log n)$}
      \begin{itemize}
        \item
          For example with a \textbf{Fibonacci heap}
        \item
          This results in a better runtime for complex graphs
          {\color{Mittel-Blau}$m \sim n^2$}
        \item
          Complex heaps create a management overhead
        \item[$\Rightarrow$]
          In practice {\color{Mittel-Blau}$m \in O(n)$} with a
          \textbf{binary heap} being faster\\
          {\color{gray}(See lecture 6)}
      \end{itemize}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Additional comments}
  \textbf{Termination criteria:}
  \begin{itemize}
    \item
      Terminate as soon as the target node {\color{Mittel-Blau}$t$} is settled\\
      %TODO: Umformulieren:
      $\ldots$ not before because tentative distance might change:
      \begin{displaymath}
        {\color{Mittel-Blau}\mathrm{td}(t) \geq \mathrm{dist}(s, t)}
      \end{displaymath}
    \item
      Before the node {\color{Mittel-Blau}$t$} is solved
      {\color{Mittel-Blau}all nodes $u$} with
      {\color{Mittel-Blau}$\mathrm{dist}(s, u) \leq \mathrm{dist}(s, t)$}
      are settled
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Additional comments}
  \textbf{Termination criteria:}
  \begin{itemize}
    \item
      Not only the {\color{Mittel-Blau}single source \textbf{single} target}
      shortest path problem is solved by the Dijkstra algorithm but also the
      {\color{Mittel-Blau}single source \textbf{all} targets} problem
    \item
      This sounds wasteful but there is not a (much) better method for general
      graphs
      {\color{gray}Intuitive:} We only know that there is no shorter path if
      all in the range of {\color{Mittel-Blau}$\mathrm{dist}(s, t)$} around
      {\color{Mittel-Blau}$s$} is evaluated
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Additional comments}
  \textbf{Calculate the shortest path:}
  \begin{itemize}
    \item
      With the current implementation of the Dijkstra algorithm we only get
      the {\color{Mittel-Blau}length} of the path\\
      {\color{gray}How to get the path too?}
    \item
      If we save the preceding node of the current shortest path on
      {\color{Mittel-Blau}relaxation} of each node we can reconstruct the
      {\color{Mittel-Blau}path}
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}
  \vspace{-1em}
  \begin{figure}[!h]
    \begin{adjustbox}{width=\linewidth}
      \def\DijkstraReverse{1}%
      \input{Images/Dijkstra/Dijkstra_Algorithm.tikz}
    \end{adjustbox}
    \vspace{-2em}
    \caption{%
      \only<1>{Start at {\color{Mittel-Blau}$u_1$}}%
      \only<2>{Iteration 1}%
      \only<3>{Iteration 2}%
      \only<4>{Iteration 3}%
      \only<5>{Iteration 4}%
      \only<6>{Iteration 5}%
      \only<7>{Iteration 6}%
    }
  \end{figure}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Additional comments}
  \textbf{Enhancement:}
  \begin{itemize}
    \item
      In our proof we used the assumption that all costs are
      {\color{Mittel-Blau}not~negative} (even $> 0$)
    \item
      With {\color{Mittel-Blau}negative costs} there might be
      {\color{Mittel-Blau}negative cycles}:
  \end{itemize}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Runtime analysis}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Runtime analysis}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}{Dijkstra Algorithm}{Runtime analysis}
\end{frame}